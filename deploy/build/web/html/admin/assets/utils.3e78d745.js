const e=!1,t=new WeakMap,s=new WeakMap,o=new WeakMap,n=(e,n,r)=>{if(!e)return()=>{};const a=((e={})=>{var t;const{root:s=null}=e;return{hash:`${e.rootMargin||"0px 0px 0px 0px"}-${Array.isArray(e.threshold)?e.threshold.join(","):null!==(t=e.threshold)&&void 0!==t?t:"0"}`,options:Object.assign(Object.assign({},e),{root:("string"==typeof s?document.querySelector(s):s)||document.documentElement})}})(n),{root:h}=a.options;let i;const l=t.get(h);let c,d;l?i=l:(i=new Map,t.set(h,i)),i.has(a.hash)?(d=i.get(a.hash),d[1].has(e)||(c=d[0],d[1].add(e),c.observe(e))):(c=new IntersectionObserver((e=>{e.forEach((e=>{if(e.isIntersecting){const t=s.get(e.target),n=o.get(e.target);t&&t(),n&&(n.value=!0)}}))}),a.options),c.observe(e),d=[c,new Set([e])],i.set(a.hash,d));let p=!1;const g=()=>{p||(s.delete(e),o.delete(e),p=!0,d[1].has(e)&&(d[0].unobserve(e),d[1].delete(e)),d[1].size<=0&&i.delete(a.hash),i.size||t.delete(h))};return s.set(e,g),o.set(e,r),g};export{e as i,n as o};
